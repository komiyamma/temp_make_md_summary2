# 第24章：実務チェックリスト＋総まとめ＋あなたの案件に当てはめ🌸🚀

---

## 24.0 まずは1分で総まとめ🔁✨（これ言えたら勝ち！）

冪等性（Idempotency）は、ざっくり言うと👇

* **同じリクエストを何回送っても、結果が壊れないこと**🔁🛡️
* 現実世界では **タイムアウト・再送・リトライが日常茶飯事**📡🌧️
* だから「たまたま上手く動いた」じゃなくて、**設計として“連打OK”にする**のが実務だよ〜😌🧠

この教材で扱った王道パーツはこれ👇（24章は“総仕上げ”！）🎓✨

* **Idempotency-Key（冪等キー）**で「同じ処理」を見分ける🔑
* **結果を保存して同じレスポンスを返す**（レスポンスキャッシュ型）📦📤
* **同時実行に勝つ**（ユニーク制約 / ロック / Atomic）⚔️🔒
* **失敗も設計する**（保存する？しない？ リトライOK/NG分類）🧯✅❌
* **非同期は“重複が普通”**（at-least-once、Outbox、コンシューマ冪等）📮📨📨
* **テスト＆観測**で「本当に壊れない」を確認する🧪👀

---

## 24.1 2026年1月時点の“周辺事情メモ”🗓️💻（知っておくと得）

実務の判断って「今の標準」に寄せたほうが事故が減るよ〜😊✨

* TypeScript は **5.9 系（5.9.3 など）**が最新リリースラインとして公開されてるよ📌 ([Microsoft for Developers][1])
* Node.js は **v24 が Active LTS**、v22 は Maintenance LTS、v25 が Current という扱いになってるよ🟩🟨🟦 ([Node.js][2])
* Node.js v24 は **2025/10 に LTS 移行（v24.11.0）**って明記されてるよ🔁 ([Node.js][3])
* Express は **v5 が正式リリース**されて、移行ガイドや codemod も用意されてるよ🚀 ([Express][4])
* 相関IDや分散トレーシングの文脈では、`traceparent` / `tracestate` の **W3C Trace Context**がベース概念として使われがちだよ👀🧵 ([W3C][5])
* OpenTelemetry（Node.js/JS）の入門ガイドや、JS SDK 2.0 のアナウンスも公式でまとまってるよ📈✨ ([OpenTelemetry][6])

---

## 24.2 実務チェックリスト（これを埋めると設計が完成する）✅🧩

ここからは **“案件で決めるべきこと”を順番に潰すリスト**だよ〜！📝💕

### A. まず「冪等が必要な操作」か判定する✅🔍

* [ ] その操作は **お金・在庫・注文確定・クーポン消費**みたいに「増える/減る」系？💳📦🧾
* [ ] 「成功したけど返事が届かなかった」時に、**再送されたら困る**？📨😇
* [ ] 同じ操作が2回走ったら、最悪どうなる？（二重決済・二重発送・二重メール）😱📩

👉 **Yes が1つでもあったら、冪等化はほぼ必須**だよ〜🔁🛡️

---

### B. API契約として“冪等の入口”を決める📜🔑

* [ ] **冪等キーはどこで受け取る？**（ヘッダーが多い：`Idempotency-Key`）🔑
* [ ] **必須にする？任意にする？**（危険操作は必須にしがち）✅
* [ ] **キーのスコープ**は？（例：`userId + key` で1セット）👤➕🔑
* [ ] **同じキーで別内容が来たらどうする？**（原則：409/422で拒否）🚫🧨
* [ ] **レスポンスは“同じキーなら同じ結果”**を返す？📦📤

---

### C. 冪等キーのルール（事故を防ぐ3点セット）🔑⏳🚫

* [ ] **TTL（有効期限）**は何日？何時間？（無限保存は避けたい）🕒
* [ ] **再利用禁止**（別注文に同じキーを使わせない）🚫
* [ ] **ユニーク制約**（DBなら `userId + idempotencyKey` を一意に）🗄️🛡️

---

### D. 保存先と保存内容を決める🧰📦

* [ ] 保存先は **DB / Redis / メモリ**どれ？（落ちたら消える？を想像）😇🗄️⚡
* [ ] 保存するのはどこまで？

  * [ ] リクエストのハッシュ（「同じ内容か」検証用）🧾
  * [ ] 結果（HTTP status / body）📦
  * [ ] 状態（processing/succeeded/failed）🔁
  * [ ] 作成日時・期限（TTL）⏳

---

### E. 同時実行に勝つ（ここが一番壊れやすい）⚔️😵‍💫

* [ ] **同時に2つ来ても“先着1つだけ実行”**になる？🏁
* [ ] 「processing のレコードを先に作る」など、**原子的に確保**できてる？⚡
* [ ] **二重実行の最後の砦**（ユニーク制約 or Atomic）ある？🛡️

---

### F. 失敗をどう扱う？（リトライOK/NG & 保存）🧯📌

* [ ] エラーを分類した？

  * リトライOK：タイムアウト/一時的ネットワーク/一時的DB不調🔁
  * リトライNG：入力不正/残高不足/権限なし🚫
* [ ] **失敗結果も保存する？**

  * 保存する：同じキーで同じ失敗を返して“暴発”を防ぐ🧯
  * 保存しない：一時障害なら次で成功させたい😌
* [ ] **「失敗を保存する場合のTTL」**は短めにする？⏳

---

### G. HTTPレスポンス（クライアントが迷わない設計）📨🧭

* [ ] 1回目成功：`201`（作成） or `200`（完了）🎉
* [ ] 2回目以降：**同じ status と body を返す**📦🔁
* [ ] 処理中：`202 Accepted` を使う？（非同期なら）🌀
* [ ] 同じキーで別内容：`409 Conflict` や `422` を使う？⚠️
* [ ] レート制限：`429` も考える？🚦

---

### H. 観測（ログ・相関ID・トレース）👀🧵

* [ ] **相関ID**（例：`X-Request-Id`）を全ログに入れる？🪪
* [ ] 冪等キーもログに入れる？（個人情報に注意しつつ）🔑🧾
* [ ] 分散トレース（`traceparent`）を引き回す？👀🧵 ([W3C][5])
* [ ] メトリクス：

  * [ ] 冪等ヒット率（2回目以降の割合）📈
  * [ ] 409/422 の発生数（キー再利用事故）⚠️
  * [ ] processing が長すぎる件数（詰まり検知）⏱️

---

### I. テスト（“壊れない”の卒業）🧪🎓

* [ ] 同じキーで **2回**叩く🔁
* [ ] 同じキーで **10回**叩く🔁🔁🔁
* [ ] **同時実行っぽく**叩く（並列）⚔️
* [ ] 途中で落ちた想定（processing のまま）で復帰できる？🧟‍♀️➡️😌
* [ ] TTL切れ後の挙動（再送はどうなる？）⏳

---

## 24.3 “よくある落とし穴”TOP10😱🕳️（ここだけは踏まないで！）

1. **キーを保存してない**（毎回新規扱い）🔑➡️🗑️
2. **キーは保存したけど結果を保存してない**（2回目が別結果になる）📦❌
3. **同じキーで別内容が来ても通してしまう**（地獄）🔥
4. **同時実行で2つとも実行される**（レース）🏁😵‍💫
5. **processing が永遠に残る**（タイムアウト戦略なし）⏱️🧟
6. **TTLが長すぎる/短すぎる**（運用が詰む）⏳🤯
7. **ログに冪等キーがなくて調査不能**👀❌
8. **非同期コンシューマが冪等じゃない**（重複配送で壊れる）📨📨💥
9. **409/422の意味が曖昧でクライアントが再送する**📨😇
10. **テストが“1回だけ”**（本番で連打されて死ぬ）🧪➡️💀

---

## 24.4 1ページ設計シート：あなたの案件に当てはめ📝🌸（このまま埋めてOK）

このシートを埋めたら、**冪等設計の骨格が完成**するよ〜！💪✨
（ミニ注文APIでも、あなたの実案件でも使える💡）

```text
【冪等設計 1ページシート】

1) 冪等が必要な操作（Yes/No）
- 操作名：
- 2回走ると何が壊れる？：
- 冪等必須？（Yes/No）：

2) 冪等キーの受け取り方
- 受け取り場所（Header / Body / URL）：
- ヘッダー名（例：Idempotency-Key）：
- 必須？（必須/任意）：

3) キースコープ & TTL
- スコープ（例：userId単位）：
- TTL（例：24時間 / 7日）：
- 再利用時の扱い（409/422 など）：

4) 保存する内容
- request hash を保存？（Yes/No）
- 結果（status/body）を保存？（Yes/No）
- 失敗も保存？（Yes/No）→ 保存するなら理由：

5) 同時実行対策
- 方式（ユニーク制約 / ロック / Atomic / 併用）：
- processing の扱い（タイムアウト/復旧方針）：

6) レスポンス設計
- 1回目成功：200/201/202？
- 2回目以降：同じレスポンス返す？（Yes/No）
- 別内容で同じキー：409/422？

7) 観測（ログ/相関ID/トレース）
- 相関ID（例：X-Request-Id）：
- ログに入れる項目（userId, key, status, latency...）：
- traceparent 対応（する/しない）：

8) テスト観点
- 2回：やる/やらない
- 10回：やる/やらない
- 同時実行：やる/やらない
- TTL切れ：やる/やらない
```

---

## 24.5 AIレビュー（穴あきチェック）用プロンプト集🤖🔍✨

### ① 設計レビュー（いちばん強い）💪

```text
あなたはシニアバックエンドエンジニアです。
以下の「冪等設計 1ページシート」をレビューして、事故りそうな穴を最大15個指摘してください。

- 指摘は「なぜ危険か」「どう直すか」をセットで
- 同時実行（レース）と、同じキーで別内容の扱いは特に厳しく
- HTTPレスポンス（200/201/202/409/422）とクライアント挙動も確認

【シート】
（ここに貼る）
```

### ② “運用目線”レビュー（障害対応したい人向け）🚑

```text
あなたはSREです。冪等設計の運用事故を防ぎたいです。
以下の設計について、監視・ログ・調査性の観点で不足を指摘し、
最低限入れるべきログ項目、メトリクス、アラート条件を提案してください。

【シート】
（ここに貼る）
```

### ③ テストケース自動生成（取捨選択する前提）🧪

```text
以下の冪等設計に対して、テストケース案を30個出してください。
カテゴリは「通常」「再送」「同時実行」「途中失敗」「TTL」「悪意ある入力」に分けてください。

【シート】
（ここに貼る）
```

---

## 24.6 さいごに：合格ライン（これ全部Yesなら実務で戦える）🎓✅💖

* [ ] 「冪等が必要な操作」を判定できた✅
* [ ] 冪等キーの **スコープ/TTL/再利用禁止**を決めた✅
* [ ] **同じキー→同じ結果**を返せる（成功も失敗も方針がある）✅
* [ ] **同時実行に勝てる**（ユニーク制約/Atomic/ロックがある）✅
* [ ] ログと相関IDで **調査できる**✅
* [ ] 2回/10回/同時実行の **テストがある**✅

ここまでできたら、冪等性は「知ってる」じゃなくて **“使える武器”**になってるよ〜！🔁🛡️✨

[1]: https://devblogs.microsoft.com/typescript/announcing-typescript-5-9/?utm_source=chatgpt.com "Announcing TypeScript 5.9"
[2]: https://nodejs.org/en/about/previous-releases?utm_source=chatgpt.com "Node.js Releases"
[3]: https://nodejs.org/en/blog/release/v24.11.0?utm_source=chatgpt.com "Node.js 24.11.0 (LTS)"
[4]: https://expressjs.com/2024/10/15/v5-release.html?utm_source=chatgpt.com "Introducing Express v5: A New Era for the Node. ..."
[5]: https://www.w3.org/TR/trace-context-2/?utm_source=chatgpt.com "Trace Context Level 2"
[6]: https://opentelemetry.io/docs/languages/js/getting-started/nodejs/?utm_source=chatgpt.com "Node.js"

