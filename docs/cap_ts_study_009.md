# 第9章：どこは即時必須？どこは遅れてOK？を仕分ける🧩✅

## 今日の結論1行✍️

**「ズレると困る場所（お金💸・法務⚖️・信頼😱）」だけを赤🟥にして、残りは黄🟨/緑🟩で“遅れても壊れない”設計に寄せる**…これが勝ち筋です😊✨

---

# 1. まず「一致してほしいもの」を3種類に分ける🧠🔍

分散の話って、いきなり難しく見えるけど…実は「何を一致させたいの？」が混ざってるだけです😵‍💫

次の3つに分けて考えると、一気にラクになります👇

* **状態（State）**：DBに入ってる“今の値”📦
  例：在庫数、注文ステータス、支払い状態
* **事実（Fact / Event）**：起きた出来事の記録📰
  例：「注文が作成された」「在庫が引かれた」「決済が確定した」
* **表示（View / UI）**：画面に見せる“見え方”🎨
  例：注文履歴の一覧、在庫の見込み表示

ポイント：
🟥にしがちなのは「表示」だけど、**本当に守るべきは「状態/事実のルール（不変条件）」**のほうです✅

---

# 2. 仕分けの軸：危険度3点セットで決める🧯⚖️😌

この章の要点はこれ👇
**業務ルールから“整合性の必要度”を分解する**ことです🧩

## 2-1. 危険度チェック（超重要）📋✅

次の質問に「YES」が多いほど、**強めの整合性が必要（赤寄り）**です🟥

1. **お金が動く？💸**

* 二重請求、取り消し漏れ、返金漏れ…は致命傷😱
* 決済APIは“再試行される前提”で作られていて、同一リクエストの再送を識別する **idempotency key** が重要になります🧷 ([Stripe Docs][1])

2. **法務/規約/監査が絡む？⚖️📑**

* 領収書、請求確定、キャンセル規約、本人確認…など
* “あとで直す”が許されない領域は赤🟥

3. **UXの信用が壊れる？😱💔**

* 「買えたと思ったのに買えてない」
* 「在庫あるって出たのに無い」
* 信頼低下は回復コストが高いです…🥲

## 2-2. もう1個だけ！「戻せるか？」🔁

* **戻せる（補償できる）**：黄🟨〜緑🟩でも設計しやすい
* **戻せない（不可逆）**：赤🟥に寄せる

---

# 3. 3色ルール：赤🟥/黄🟨/緑🟩で切る🎨✨

ここからは、迷わないための“型”です👍

## 🟥 赤（強整合寄り）

* **二重実行・取り消し漏れが事故になる**
* **同時に更新されたら困る**
* 例：決済の確定（キャプチャ）、在庫の引当（予約確定）

> 例：決済で「オーソリ（与信）→キャプチャ（確定）」の分離を使う場合、PaymentIntent作成時に `capture_method=manual` を設定して後でキャプチャする…みたいな流れがよく使われます📌 ([support.stripe.com][2])

## 🟨 黄（中間：自分の画面だけは新しく見せたい等）

* **「自分が今した操作は、すぐ反映して見たい」**👤✅
* 他人の画面は多少遅れてもOK、みたいなやつ

## 🟩 緑（遅延OK）

* **多少古くても困らない（しかも速い⚡）**
* 例：商品一覧の在庫目安、ランキング、分析系

> 在庫の例だと「予約（引当）は正確に」「在庫の参照表示は多少古くてもOK」という整理が実務でも語られます🧠 ([Salesforce Engineering Blog][3])

---

# 4. 題材ドメイン（在庫・注文・決済）を色分けしてみよう🛒📦💳

ここが本章のメイン演習です🎯
まずは“ありがちなEC”で、判断の型を作ります😊

## 4-1. 仕分け例（完成形イメージ）🟥🟨🟩

| 領域   | 具体項目               |   推奨色 | 理由（危険度）                                 |
| ---- | ------------------ | ----: | --------------------------------------- |
| 在庫📦 | 商品一覧に出す在庫目安        |    🟩 | 少し古くても致命傷になりにくい                         |
| 在庫📦 | **在庫引当（予約）**       |    🟥 | oversell（売りすぎ）防止が必要                     |
| 注文🛒 | 注文受付（とりあえず受ける）     | 🟨〜🟩 | A寄りにしやすい（後で確定/失敗通知）                     |
| 注文🛒 | 注文確定（出荷確定など）       | 🟥〜🟨 | ここでズレるとクレームに直結😱                        |
| 決済💳 | 決済状況の表示（反映待ち表示）    | 🟨〜🟩 | “処理中”でUX吸収できる                           |
| 決済💳 | **キャプチャ（確定）/返金確定** |    🟥 | お金は最重要💸（再試行前提＋冪等が鍵） ([Stripe Docs][1]) |

---

# 5. ハンズオン①：あなたの題材を「色分けシート」にする📝🎨

## 5-1. 手順（簡単）😊

1. まず「画面」を列挙する📱
   例：商品一覧、商品詳細、カート、注文確認、注文履歴
2. 各画面で表示しているデータを書き出す✍️
3. 各データを **赤/黄/緑** に分類する🟥🟨🟩
4. その横に「理由」を1行で書く（危険度3点セット）💸⚖️😌

## 5-2. 空のテンプレ（これを埋める）📄✨

| 画面   | 表示/操作 | データ（状態/事実/表示） |  色 | 理由 |
| ---- | ----- | ------------- | -: | -- |
| 商品一覧 | 表示    | 在庫目安（表示）      |    |    |
| 注文確認 | 操作    | 注文作成（事実）      |    |    |
| 決済完了 | 操作    | キャプチャ（事実/状態）  |    |    |

---

# 6. ハンズオン②：色分けを“設定ファイル”にしてコードへ反映🧩💻

「決めたこと」をコードに落とすと、設計が一気に強くなります💪✨
ここでは **“整合性ポリシー表”** をJSONにして読み込むだけの超ミニ実装です👍

## 6-1. `consistency-map.json` を作る📄

```json
{
  "inventory.readAvailability": { "level": "eventual", "color": "green", "reason": "一覧は目安でOK" },
  "inventory.reserve": { "level": "strong", "color": "red", "reason": "売りすぎ防止" },

  "order.accept": { "level": "available", "color": "yellow", "reason": "受付は止めない（後で確定）" },
  "order.confirm": { "level": "strong", "color": "red", "reason": "確定後のズレは事故" },

  "payment.showStatus": { "level": "eventual", "color": "green", "reason": "処理中表示で吸収" },
  "payment.capture": { "level": "strong", "color": "red", "reason": "お金は最重要・冪等必須" }
}
```

## 6-2. 読み込んで使う（最小）📦

```ts
import fs from "node:fs";

type Color = "red" | "yellow" | "green";
type Level = "strong" | "available" | "eventual";

type Policy = { level: Level; color: Color; reason: string };
type PolicyMap = Record<string, Policy>;

export function loadPolicyMap(path: string): PolicyMap {
  return JSON.parse(fs.readFileSync(path, "utf-8")) as PolicyMap;
}

export function mustBeStrong(op: string, map: PolicyMap): boolean {
  return map[op]?.level === "strong";
}
```

## 6-3. 使いどころ（例）🎛️

* `POST /payments/capture` のような“赤🟥”操作は、**同期で失敗を返す**（成功/失敗をその場で確定）
* `POST /orders` のような“黄🟨”は、**受付だけして後で確定**（画面は「処理中」表示）

※この「後で確定」の見せ方は次章（UXで支える）で本格的にやります🎨⏳

---

# 7. AIで“仕分け基準チェックリスト”を作って、ブレを減らす🤖📋✨

人間って、日によって判断がブレます😂
だから、ここはAIを“基準の見張り役”にするのが強いです👀✅

## 7-1. AIに投げるお題（そのまま使ってOK）💬

* 「在庫・注文・決済の各操作を、赤🟥/黄🟨/緑🟩に分類して。分類基準は“お金💸/法務⚖️/UX😌/戻せるか🔁”で理由も1行で。」
* 「“緑🟩に倒しすぎて事故るパターン”を5つ出して。どの操作が危険かも書いて。」

## 7-2. AIの回答を鵜呑みにしないコツ🧠

* **“戻せる？”を必ず聞き返す**（補償の可否）🔁
* 決済系は **再試行が普通** → **冪等前提** を外さない🧷 ([Stripe Docs][1])

---

# 8. よくある事故パターン集😱💥（ここだけは覚えてOK）

* 🟥にすべきものを🟩にした
  → 例：在庫引当を遅延OKにして、売りすぎが発生📦💥
* “表示”だけ強くして、“状態”が弱い
  → 画面は正しそうに見えるのに、裏で矛盾して地獄😵‍💫
* 決済を「一回しか来ない前提」で作る
  → ネットワーク再送で二重実行…😱（だから冪等が超重要）🧷 ([Stripe Docs][1])

---

# 9. ミニクイズ（理解チェック）🧠✅

## Q1：商品一覧の「在庫あと3個！」は何色？🎨

* A：🟩 が多い（目安表示ならOK）
* ただし「残り1個限定セール！」みたいに**契約になってる**なら🟨〜🟥もあり⚠️

## Q2：決済のキャプチャは何色？💳

* A：🟥（お金は最重要）
  しかも再試行前提なので、同一リクエストを識別する仕組み（冪等）が鍵🧷 ([Stripe Docs][1])

## Q3：在庫の「引当（予約）」と「参照表示」が同じ色になるのは変？📦

* A：だいたい変！
  予約は正確さが必要で、参照は多少古くてもOKにできることが多いです🧠 ([Salesforce Engineering Blog][3])

---

# 補足：CAPの“今っぽい”捉え方（超短く）⚖️✨

* 現場では「分断が起きたらどうする？」を**明示的に扱う**のが大事で、検知→分断モード→復旧、みたいな整理が語られます🧯 ([UCSBコンピュータサイエンス][4])
* さらに、分断がなくても「一致を取りに行くほど遅くなる（遅延）」というトレードオフがあり、PACELCとして説明されることもあります⏳ ([cs.umd.edu][5])

---

# まとめ📘✨

* 整合性は「全部強く」じゃなくて、**赤🟥を最小化するゲーム**🎮
* 判断基準は **お金💸 / 法務⚖️ / UX😌 + 戻せるか🔁**
* 仕分け結果は **表にして固定** → JSON化 → コードに反映🧩💻
* 決済のように再試行が前提の領域は、**冪等（idempotency）**が必須🧷 ([Stripe Docs][1])

[1]: https://docs.stripe.com/api/idempotent_requests?utm_source=chatgpt.com "Idempotent requests | Stripe API Reference"
[2]: https://support.stripe.com/questions/using-authorization-and-capture-with-paymentintents?locale=ja-JP&utm_source=chatgpt.com "PaymentIntents でオーソリとキャプチャーを利用する"
[3]: https://engineering.salesforce.com/event-sourcing-for-an-inventory-availability-solution-3cc0daf5a742/?utm_source=chatgpt.com "Event Sourcing for an Inventory Availability Solution"
[4]: https://sites.cs.ucsb.edu/~rich/class/cs293b-cloud/papers/brewer-cap.pdf?utm_source=chatgpt.com "CAP Twelve Years Later: How the “Rules” Have Changed"
[5]: https://www.cs.umd.edu/~abadi/papers/abadi-pacelc.pdf?utm_source=chatgpt.com "Consistency Tradeoffs in Modern Distributed Database ..."
