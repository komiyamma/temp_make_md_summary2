# ç¬¬32ç« ï¼šProjectionå†æ§‹ç¯‰ï¼ˆãƒªãƒ—ãƒ¬ã‚¤ï¼‰ğŸ”ğŸ§¹

## ã“ã®ç« ã§ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã“ã¨ğŸ¯âœ¨

* Projectionï¼ˆèª­ã¿ãƒ¢ãƒ‡ãƒ«ï¼‰ã‚’ **ã„ã£ãŸã‚“æ¶ˆã—ã¦**ã€ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ€åˆã‹ã‚‰æµã—ã¦ **ä½œã‚Šç›´ã›ã‚‹** ã‚ˆã†ã«ãªã‚‹ğŸ˜ŠğŸ”
* ã€Œå£Šã‚ŒãŸã€ã€Œã‚ºãƒ¬ãŸã€ã€Œè¿½åŠ ã—ãŸã„ã€ã‚’ **ãƒªãƒ—ãƒ¬ã‚¤ã§å›å¾©**ã§ãã‚‹æ„Ÿè¦šãŒã¤ãğŸ’ªâœ¨
* æœ¬ç•ªã£ã½ãã™ã‚‹ãŸã‚ã® **ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼ˆã©ã“ã¾ã§å‡¦ç†ã—ãŸã‹ï¼‰** ã‚‚å…¥é–€ã§ãã‚‹ğŸğŸ‘€

---

# 1. Projectionã£ã¦ã€Œä½œã‚Šç›´ã›ã‚‹ã€å‰æã®ãƒ‡ãƒ¼ã‚¿ã ã‚ˆğŸ§ âœ¨

ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ã§ã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆã¯ã€Œèµ·ããŸäº‹å®Ÿã€ã‚’ç©ã‚€æ–¹å¼ã§ã€ãã“ã‹ã‚‰çŠ¶æ…‹ã‚„èª­ã¿ãƒ¢ãƒ‡ãƒ«ã‚’å†ç”Ÿæˆã§ãã¾ã™ã€‚ã¤ã¾ã‚Š Projection ã¯ **æ´¾ç”Ÿç‰©** ãªã®ã§ã€æœ€æ‚ª **æ¶ˆã—ã¦å†æ§‹ç¯‰**ã§ãã‚‹ã®ãŒå¼·ã¿ã§ã™ğŸ˜ŠğŸ§¹ğŸ” ([Microsoft Learn][1])

---

# 2. Projectionã‚’å†æ§‹ç¯‰ã—ãŸããªã‚‹å…¸å‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ã‚‹ã‚ã‚‹ğŸ˜µâ€ğŸ’«â¡ï¸ğŸ˜Š

## ã‚ˆãã‚ã‚‹ç†ç”±ğŸ§©

* **ãƒã‚°ã§ProjectionãŒã‚ºãƒ¬ãŸ**ï¼ˆ1ã‚¤ãƒ™ãƒ³ãƒˆã®åæ˜ æ¼ã‚Œã€ã¨ã‹ï¼‰ğŸ›ğŸ’¥
* **æ–°ã—ã„ä¸€è¦§ç”»é¢ãŒæ¬²ã—ã„** â†’ æ–°Projectionã‚’è¿½åŠ ã—ãŸã„ğŸ†•ğŸ“‹
* **Projectionã®ã‚¹ã‚­ãƒ¼ãƒã‚’å¤‰ãˆãŸã„**ï¼ˆè¡¨ç¤ºé …ç›®ã‚’å¢—ã‚„ã™ç­‰ï¼‰ğŸ§¾â•
* **ã‚¤ãƒ™ãƒ³ãƒˆæ•°ãŒå¢—ãˆã¦å‡¦ç†æ–¹å¼ã‚’å¤‰ãˆãŸã„**ï¼ˆãƒãƒƒãƒåŒ–ã€æœ€é©åŒ–ï¼‰âš¡

## ã“ã“ã§å¤§äº‹ãªæ„Ÿè¦šğŸ’¡

* ã‚¤ãƒ™ãƒ³ãƒˆï¼šãªã‚‹ã¹ã **æ¶ˆã•ãªã„ãƒ»æ”¹ã–ã‚“ã—ãªã„**ï¼ˆå±¥æ­´ï¼‰ğŸ“œ
* Projectionï¼šå£Šã‚ŒãŸã‚‰ **æ¨ã¦ã¦ä½œã‚Šç›´ã™**ï¼ˆæ´¾ç”Ÿï¼‰ğŸ—‘ï¸â¡ï¸ğŸ—ï¸

---

# 3. ãƒªãƒ—ãƒ¬ã‚¤å†æ§‹ç¯‰ã®3ã¤ã®ãƒ¬ãƒ™ãƒ«ğŸšï¸ï¼ˆå­¦ç¿’â†’å®Ÿå‹™ï¼‰

## ãƒ¬ãƒ™ãƒ«Aï¼šå­¦ç¿’ç”¨ï¼ˆã„ã¡ã°ã‚“ç°¡å˜ï¼‰ğŸ€

1. Projectionã‚’å…¨éƒ¨æ¶ˆã™
2. å…ˆé ­ã‹ã‚‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’å…¨éƒ¨æµã™
3. ã§ããŸProjectionã‚’ä¿å­˜ã™ã‚‹
   â†’ å°ã•ã„ã‚¢ãƒ—ãƒªãªã‚‰ã“ã‚Œã§OKğŸ˜Šâœ…

## ãƒ¬ãƒ™ãƒ«Bï¼šå®Ÿå‹™ã£ã½ã„ï¼ˆåˆ‡ã‚Šæ›¿ãˆæ–¹å¼ï¼‰ğŸ”ğŸš¦

* æ–°ã—ã„Projectionç½®ãå ´ï¼ˆä¾‹ï¼šãƒ†ãƒ¼ãƒ–ãƒ« `Projection_v2`ï¼‰ã«å†æ§‹ç¯‰ã—ã¦
* æœ€å¾Œã« **åˆ‡ã‚Šæ›¿ãˆã‚‹**ï¼ˆã‚¹ã‚¤ãƒƒãƒï¼‰
  â†’ å†æ§‹ç¯‰ä¸­ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¦ã‚‹ç”»é¢ã‚’å£Šã—ã«ãã„ğŸ‘€âœ¨

## ãƒ¬ãƒ™ãƒ«Cï¼šæœ¬ç•ªã‚¬ãƒå¯„ã‚Šï¼ˆè¿½ã„ã‹ã‘ï¼Catch-upï¼‰ğŸƒâ€â™€ï¸ğŸ’¨

* ã€Œã“ã“ã¾ã§å‡¦ç†ã—ãŸã€åœ°ç‚¹ï¼ˆãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼‰ã‚’è¦šãˆã¦
* å†æ§‹ç¯‰å¾Œã« **å·®åˆ†ã ã‘è¿½ã„ã‹ã‘**ã¦æœ€æ–°ã«ãã‚ãˆã‚‹
  â†’ ãšã£ã¨å‹•ã‹ã—ãªãŒã‚‰ã§ã‚‚æ•´åˆã•ã›ã‚„ã™ã„ğŸ”âœ…

---

# 4. ä»Šæ—¥ã®ã‚´ãƒ¼ãƒ«ï¼šãƒ¬ãƒ™ãƒ«Aï¼‹ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆå…¥é–€ğŸğŸ˜Š

ã“ã“ã§ã¯ã€Œã‚¤ãƒ™ãƒ³ãƒˆã‚’æœ€åˆã‹ã‚‰å…¨éƒ¨èª­ã‚€ã€ãŸã‚ã«ã€ã‚¤ãƒ™ãƒ³ãƒˆã« **é€šã—ç•ªå·ï¼ˆPositionï¼‰** ã‚’ä»˜ã‘ã¾ã™ğŸ“¼ğŸ”¢
ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã® version ã¯ã€Œãã®é›†ç´„å†…ã®é †ç•ªã€ã€Position ã¯ã€Œå…¨ä½“ã®é †ç•ªã€ã£ã¦ã‚¤ãƒ¡ãƒ¼ã‚¸ã ã‚ˆğŸ˜Šï¼‰

ã‚ã¨ã€2026ã®æœ€æ–°å‰æã¨ã—ã¦ã¯ **.NET 10ï¼ˆLTSï¼‰** ãŒåŸºæœ¬ç·šã§ã€2026-01-13æ™‚ç‚¹ã®æ›´æ–°ã‚‚å‡ºã¦ã„ã¾ã™ğŸ§°âœ¨ ([Microsoft][2])
C# ã‚‚ .NET 10 / Visual Studio 2026 ã§ **C# 14** ãŒè©¦ã›ã¾ã™ğŸ§âœ¨ ([Microsoft Learn][3])

---

# 5. å®Ÿè£…ï¼šã‚¤ãƒ™ãƒ³ãƒˆã‚’ã€Œå…¨ä½“é †ã€ã§èª­ã‚ã‚‹ã‚ˆã†ã«ã™ã‚‹ğŸ“¦â¡ï¸ğŸ“š

## 5.1 EventEnvelopeï¼ˆã‚¤ãƒ™ãƒ³ãƒˆã®å°ç­’ï¼‰âœ‰ï¸

* Projectionæ›´æ–°ã§ã¯ã€Œã‚¤ãƒ™ãƒ³ãƒˆæœ¬ä½“ã€ã ã‘ã˜ã‚ƒãªãã¦
  **Position / StreamId / Version / ç™ºç”Ÿæ™‚åˆ»** ãªã©ã‚‚æ¬²ã—ããªã‚ŠãŒã¡ğŸ·ï¸âœ¨

```csharp
public sealed record EventEnvelope(
    long Position,
    string StreamId,
    int Version,
    DateTimeOffset OccurredAt,
    object Event
);
```

---

## 5.2 IEventStoreï¼ˆReadAllã‚’è¿½åŠ ï¼‰ğŸ“šğŸ”

æ—¢å­˜ã® `ReadStream(streamId)` ã¨ã¯åˆ¥ã«ã€Projectionå†æ§‹ç¯‰ç”¨ã«ã€Œå…¨ã‚¤ãƒ™ãƒ³ãƒˆã€ã‚’èª­ã¿ãŸã„ã§ã™ã€‚

```csharp
public interface IEventStore
{
    Task AppendAsync(string streamId, int expectedVersion, IReadOnlyList<object> events);

    Task<IReadOnlyList<EventEnvelope>> ReadStreamAsync(string streamId);

    // âœ… Projectionå†æ§‹ç¯‰ã®ä¸»å½¹ï¼šå…¨ä½“ã®é †ç•ªã§èª­ã‚€
    Task<IReadOnlyList<EventEnvelope>> ReadAllAsync(long fromExclusivePosition, int maxCount);
}
```

---

## 5.3 ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªEventStoreï¼ˆæœ€å°å®Ÿè£…ï¼‰ğŸ§ºâœ¨

Position ã¯ Append ã®ãŸã³ã«å¢—ãˆã‚‹é€šã—ç•ªå·ã«ã—ã¾ã™ğŸ“ˆ

```csharp
using System.Collections.Concurrent;
using System.Threading;

public sealed class InMemoryEventStore : IEventStore
{
    private readonly ConcurrentDictionary<string, List<EventEnvelope>> _streams = new();
    private readonly List<EventEnvelope> _all = new();
    private long _position = 0;

    public Task AppendAsync(string streamId, int expectedVersion, IReadOnlyList<object> events)
    {
        var stream = _streams.GetOrAdd(streamId, _ => new List<EventEnvelope>());

        // expectedVersionãƒã‚§ãƒƒã‚¯ï¼ˆè¶…ã–ã£ãã‚Šï¼‰
        var currentVersion = stream.Count == 0 ? -1 : stream[^1].Version;
        if (currentVersion != expectedVersion)
            throw new InvalidOperationException($"Concurrency conflict. expected={expectedVersion}, actual={currentVersion}");

        foreach (var e in events)
        {
            var nextVersion = currentVersion + 1;
            currentVersion = nextVersion;

            var pos = Interlocked.Increment(ref _position);
            var env = new EventEnvelope(
                Position: pos,
                StreamId: streamId,
                Version: nextVersion,
                OccurredAt: DateTimeOffset.UtcNow,
                Event: e
            );

            stream.Add(env);
            _all.Add(env);
        }

        return Task.CompletedTask;
    }

    public Task<IReadOnlyList<EventEnvelope>> ReadStreamAsync(string streamId)
    {
        if (!_streams.TryGetValue(streamId, out var stream))
            return Task.FromResult<IReadOnlyList<EventEnvelope>>(Array.Empty<EventEnvelope>());

        return Task.FromResult<IReadOnlyList<EventEnvelope>>(stream.ToList());
    }

    public Task<IReadOnlyList<EventEnvelope>> ReadAllAsync(long fromExclusivePosition, int maxCount)
    {
        var batch = _all
            .Where(x => x.Position > fromExclusivePosition)
            .OrderBy(x => x.Position)
            .Take(maxCount)
            .ToList();

        return Task.FromResult<IReadOnlyList<EventEnvelope>>(batch);
    }
}
```

---

# 6. Projectionå´ï¼šApplyã§èª­ã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ›´æ–°ã™ã‚‹ğŸ”ğŸ§±

ã“ã“ã§ã¯ä¾‹ã¨ã—ã¦ã€Œã‚«ãƒ¼ãƒˆã®ä¸€è¦§è¡¨ç¤ºç”¨Projectionã€ã‚’ä½œã‚‹æƒ³å®šã«ã—ã¾ã™ğŸ›’ğŸ“‹
ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆåã¯é›°å›²æ°—ã§OKã€‚å‰ç« ã¾ã§ã®é¡Œæã«åˆã‚ã›ã¦èª­ã¿æ›¿ãˆã¦ã­ğŸ˜Šï¼‰

## 6.1 ProjectionãŒå®ˆã‚‹ã¹ããƒ«ãƒ¼ãƒ«3ã¤ğŸ§·âœ¨

1. **åŒã˜ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚‚ã†ä¸€å›å—ã‘ã¦ã‚‚å£Šã‚Œã«ãã„**ï¼ˆã§ãã‚Œã°ï¼‰ğŸ”âœ…
2. **å¤–éƒ¨å‰¯ä½œç”¨ã‚’èµ·ã“ã•ãªã„**ï¼ˆãƒ¡ãƒ¼ãƒ«é€ä¿¡ã¨ã‹ã—ãªã„ï¼‰ğŸ“­ğŸš«
3. **DateTime.Nowã§çµæœãŒå¤‰ã‚ã‚‹**ã¿ãŸã„ãªéæ±ºå®šæ€§ã‚’é¿ã‘ã‚‹â°ğŸš«

## 6.2 IProjectionï¼ˆæœ€å°ï¼‰ğŸ§©

```csharp
public interface IProjection
{
    string Name { get; }
    Task ResetAsync();                    // å…¨æ¶ˆã—ï¼ˆå†æ§‹ç¯‰ç”¨ï¼‰
    Task ApplyAsync(EventEnvelope env);   // 1ã‚¤ãƒ™ãƒ³ãƒˆåæ˜ 
}
```

## 6.3 Projectionï¼ˆã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªï¼‰ä¾‹ğŸ“‹

```csharp
using System.Collections.Concurrent;

public sealed record CartSummary(string CartId, int ItemCount);

public sealed class CartSummaryProjection : IProjection
{
    public string Name => "CartSummary";

    private readonly ConcurrentDictionary<string, int> _itemCounts = new();

    public Task ResetAsync()
    {
        _itemCounts.Clear();
        return Task.CompletedTask;
    }

    public Task ApplyAsync(EventEnvelope env)
    {
        var cartId = env.StreamId;

        switch (env.Event)
        {
            case CartCreated:
                _itemCounts[cartId] = 0;
                break;

            case ItemAdded:
                _itemCounts.AddOrUpdate(cartId, 1, (_, old) => old + 1);
                break;

            case ItemRemoved:
                _itemCounts.AddOrUpdate(cartId, 0, (_, old) => Math.Max(0, old - 1));
                break;
        }

        return Task.CompletedTask;
    }

    // ç”»é¢ç”¨ã«å–ã‚Šå‡ºã™ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆãŠå¥½ã¿ã§ï¼‰
    public IReadOnlyList<CartSummary> GetAll()
        => _itemCounts.Select(kv => new CartSummary(kv.Key, kv.Value)).ToList();
}

// ä¾‹ã®ã‚¤ãƒ™ãƒ³ãƒˆå‹ï¼ˆæœ€å°ï¼‰
public sealed record CartCreated;
public sealed record ItemAdded(string Sku);
public sealed record ItemRemoved(string Sku);
```

---

# 7. å†æ§‹ç¯‰ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆãƒªãƒ—ãƒ¬ã‚¤æœ¬ä½“ï¼‰ğŸ”ğŸ§¹âœ¨

## 7.1 ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼ˆã©ã“ã¾ã§å‡¦ç†ã—ãŸã‹ï¼‰ğŸ

æœ€å°ã¯ã€Œæœ€å¾Œã«å‡¦ç†ã—ãŸPositionã€ã‚’ä¿å­˜ã™ã‚Œã°OKã§ã™ã€‚

```csharp
public interface ICheckpointStore
{
    Task<long> LoadAsync(string projectionName);
    Task SaveAsync(string projectionName, long position);
}

public sealed class InMemoryCheckpointStore : ICheckpointStore
{
    private readonly Dictionary<string, long> _map = new();

    public Task<long> LoadAsync(string projectionName)
        => Task.FromResult(_map.TryGetValue(projectionName, out var pos) ? pos : 0);

    public Task SaveAsync(string projectionName, long position)
    {
        _map[projectionName] = position;
        return Task.CompletedTask;
    }
}
```

> ã“ã“ã§ã® 0 ã¯ã€Œæœªå‡¦ç†ã€æ‰±ã„ã«ã—ã¦ã¾ã™ğŸ˜Šï¼ˆPositionã¯ 1 ã‹ã‚‰å§‹ã¾ã‚‹æƒ³å®šï¼‰

---

## 7.2 Rebuildï¼ˆå…¨æ¶ˆã—â†’å…¨æµã—ï¼‰ğŸš¿â¡ï¸ğŸ—ï¸

```csharp
public sealed class ProjectionRebuilder
{
    private readonly IEventStore _eventStore;
    private readonly ICheckpointStore _checkpointStore;

    public ProjectionRebuilder(IEventStore eventStore, ICheckpointStore checkpointStore)
    {
        _eventStore = eventStore;
        _checkpointStore = checkpointStore;
    }

    public async Task RebuildAsync(IProjection projection, int batchSize = 200)
    {
        // 1) å…¨æ¶ˆã—
        await projection.ResetAsync();

        // 2) ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚‚ãƒªã‚»ãƒƒãƒˆ
        await _checkpointStore.SaveAsync(projection.Name, 0);

        long pos = 0;

        while (true)
        {
            var batch = await _eventStore.ReadAllAsync(pos, batchSize);
            if (batch.Count == 0) break;

            foreach (var env in batch)
            {
                await projection.ApplyAsync(env);
                pos = env.Position;

                // å°ã•ãã¦ã‚‚ã€Œé€²æ—ä¿å­˜ã€ã—ã¦ãŠãã¨å®‰å¿ƒğŸ˜Š
                await _checkpointStore.SaveAsync(projection.Name, pos);
            }
        }
    }
}
```

---

# 8. ãƒŸãƒ‹æ¼”ç¿’ï¼šProjectionã‚’æ¶ˆã—ã¦ã€ãƒªãƒ—ãƒ¬ã‚¤ã§å¾©æ´»ã•ã›ã‚ˆã†ğŸ§ªğŸ®

## æ¼”ç¿’1ï¼šã‚ã–ã¨å£Šã—ã¦ç›´ã™ğŸ˜ˆâ¡ï¸ğŸ˜‡

1. ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã„ãã¤ã‹ç©ã‚€ï¼ˆã‚«ãƒ¼ãƒˆã‚’ä½œã£ã¦å•†å“ã‚’è¶³ã™ï¼‰ğŸ›’â•
2. Projectionã‚’ `ResetAsync()` ã§æ¶ˆã™ğŸ§¹
3. ä¸€è¦§ãŒç©ºã«ãªã‚‹ã®ã‚’ç¢ºèªğŸ‘€
4. `RebuildAsync()` ã‚’å‘¼ã¶ğŸ”
5. ä¸€è¦§ãŒæˆ»ã‚‹ã®ã‚’ç¢ºèªğŸ‰

## æ¼”ç¿’2ï¼šåæ˜ æ¼ã‚Œã‚’ä½œã£ã¦æ¤œçŸ¥ã™ã‚‹ğŸ‘€ğŸ›

* `ItemRemoved` ã®å‡¦ç†ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ãƒªãƒ“ãƒ«ãƒ‰
* ã€Œãªã‚“ã‹æ•°ãŒåˆã‚ãªã„â€¦ã€ã‚’ä½“é¨“ã—ã¦ã‹ã‚‰æˆ»ã™
  â†’ Projectionã¯ **ã‚ºãƒ¬ã¦ã‚‚ç›´ã›ã‚‹** ã‚’ä½“ã§è¦šãˆã‚‹ğŸ’ªâœ¨

---

# 9. ãƒ†ã‚¹ãƒˆï¼šå†æ§‹ç¯‰ã¯â€œåŒã˜å…¥åŠ›ãªã‚‰åŒã˜çµæœâ€ãŒå‘½ğŸ§ªğŸ’

## Given-When-Thenï¼ˆå†æ§‹ç¯‰ç‰ˆï¼‰ğŸŒ¸

* Givenï¼šã‚¤ãƒ™ãƒ³ãƒˆåˆ—ï¼ˆCartCreated, ItemAdded, ItemAdded, ItemRemovedï¼‰
* Whenï¼šRebuild
* Thenï¼šItemCount ãŒæœŸå¾…ã©ãŠã‚Šï¼ˆä¾‹ï¼š1ï¼‰

```csharp
using Xunit;

public class ProjectionRebuildTests
{
    [Fact]
    public async Task Rebuild_replays_events_and_restores_projection()
    {
        var store = new InMemoryEventStore();
        var cp = new InMemoryCheckpointStore();
        var projection = new CartSummaryProjection();
        var rebuilder = new ProjectionRebuilder(store, cp);

        var cartId = "cart-1";

        await store.AppendAsync(cartId, -1, new object[] { new CartCreated() });
        await store.AppendAsync(cartId, 0,  new object[] { new ItemAdded("A") });
        await store.AppendAsync(cartId, 1,  new object[] { new ItemAdded("B") });
        await store.AppendAsync(cartId, 2,  new object[] { new ItemRemoved("A") });

        // ã‚ã–ã¨æ¶ˆã™
        await projection.ResetAsync();

        // å†æ§‹ç¯‰
        await rebuilder.RebuildAsync(projection);

        var list = projection.GetAll();
        Assert.Single(list);
        Assert.Equal(1, list[0].ItemCount);
    }
}
```

---

# 10. ã‚ˆãã‚ã‚‹è½ã¨ã—ç©´ï¼ˆã“ã“ã ã‘è¦‹ã‚Œã°äº‹æ•…æ¸›ã‚‹ï¼‰ğŸ§¯âœ¨

## è½ã¨ã—ç©´1ï¼šProjectionã§å‰¯ä½œç”¨ã—ã¡ã‚ƒã†ğŸ“£ğŸ’¥

* å†æ§‹ç¯‰ã§éå»ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½•åƒä»¶ã‚‚æµã™
* ãã®ãŸã³ã«ã€Œé€šçŸ¥ãƒ¡ãƒ¼ãƒ«é€ä¿¡ã€ã¿ãŸã„ãªã®ã‚’ã™ã‚‹ã¨åœ°ç„ğŸ“©ğŸ˜±
  âœ… Projectionã¯ **è¡¨ç¤ºç”¨ã«å¾¹ã™ã‚‹** ã®ãŒå®‰å…¨ğŸ˜Š

## è½ã¨ã—ç©´2ï¼šé †ç•ªãŒç‹‚ã†ğŸ”€ğŸ˜µ

* ã‚¤ãƒ™ãƒ³ãƒˆã¯åŸºæœ¬ã€Œé †ç•ªãŒå‘½ã€
  âœ… `Position` ã‚„ `Version` ã‚’ä½¿ã£ã¦ **å¿…ãšé †ã«é©ç”¨**ğŸ”¢âœ…

## è½ã¨ã—ç©´3ï¼šéæ±ºå®šæ€§ï¼ˆæ¯å›çµæœãŒå¤‰ã‚ã‚‹ï¼‰ğŸ²

* `DateTime.Now` ã§ã€Œä»Šæ—¥ã®è¡¨ç¤ºã€ã‚’ä½œã‚‹ã€ã¿ãŸã„ãªã®ã¯å†æ§‹ç¯‰ã§ã‚ºãƒ¬ãŒã¡
  âœ… â€œã‚¤ãƒ™ãƒ³ãƒˆã«å…¥ã£ã¦ã‚‹äº‹å®Ÿâ€ã‹ã‚‰è¨ˆç®—ã™ã‚‹ğŸ§ âœ…

---

# 11. AIæ´»ç”¨ï¼šå†æ§‹ç¯‰ã®æŠœã‘æ¼ã‚Œã‚’æ¸›ã‚‰ã™ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé›†ğŸ¤–ğŸª„

## 11.1 ã€ŒApplyæ¼ã‚Œã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¾é ¼ğŸ‘€

```text
æ¬¡ã®Projectionã®Applyå®Ÿè£…ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ã€‚
è¦³ç‚¹ã¯(1)ã‚¤ãƒ™ãƒ³ãƒˆåæ˜ æ¼ã‚Œ(2)éæ±ºå®šæ€§(3)å‰¯ä½œç”¨(4)åŒä¸€ã‚¤ãƒ™ãƒ³ãƒˆã®äºŒé‡é©ç”¨è€æ€§ã€‚
ä¸è¶³ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Œã°ã€è¿½åŠ ã™ã¹ãswitchåˆ†å²ã‚’ææ¡ˆã—ã¦ã€‚
```

## 11.2 ã€Œå†æ§‹ç¯‰ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã€ç”ŸæˆğŸ“‹âœ¨

```text
Projectionå†æ§‹ç¯‰ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆå…¨ãƒªãƒ—ãƒ¬ã‚¤ï¼‰ã®é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ä½œã£ã¦ã€‚
æ‰‹é †ã€ãƒ­ã‚°ã€æ‰€è¦æ™‚é–“è¨ˆæ¸¬ã€å¤±æ•—æ™‚ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€ç¢ºèªè¦³ç‚¹ã¾ã§å…¥ã‚Œã¦ã€‚
åˆå¿ƒè€…ãŒãã®ã¾ã¾èª­ã‚ã‚‹çŸ­ã„ç®‡æ¡æ›¸ãã§ã€‚
```

## 11.3 ã€ŒGiven-When-Thenã®ãƒ†ã‚¹ãƒˆæ¡ˆã€é‡ç”£ğŸ§ª

```text
ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆåˆ—ã®ä¾‹ã‚’10ãƒ‘ã‚¿ãƒ¼ãƒ³ä½œã£ã¦ã€Given-When-Thenã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã«ã—ã¦ã€‚
æˆåŠŸã ã‘ã§ãªãå¤±æ•—ç³»ï¼ˆä¸å¤‰æ¡ä»¶é•åã®å‰æï¼‰ã‚‚æ··ãœã¦ã€‚
```

---

# 12. ã¾ã¨ã‚ğŸŒŸ

* Projectionã¯ **æ´¾ç”Ÿãƒ‡ãƒ¼ã‚¿**ã ã‹ã‚‰ã€å£Šã‚ŒãŸã‚‰ **æ¶ˆã—ã¦ãƒªãƒ—ãƒ¬ã‚¤ã§å¾©æ´»**ã§ãã‚‹ğŸ”ğŸ§¹
* å†æ§‹ç¯‰ã«ã¯ã€Œå…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’é †ã«èª­ã‚€ã€ä»•çµ„ã¿ï¼ˆPositionï¼‰ãŒä¾¿åˆ©ğŸ“¼ğŸ”¢
* ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’æŒã¤ã¨ã€é‹ç”¨ãŒä¸€æ°—ã«ãƒ©ã‚¯ã«ãªã‚‹ğŸğŸ˜Š
* ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ã§ã¯ã€Œå±¥æ­´ï¼ˆã‚¤ãƒ™ãƒ³ãƒˆï¼‰â†’å†ç”Ÿæˆï¼ˆçŠ¶æ…‹/èª­ã¿ãƒ¢ãƒ‡ãƒ«ï¼‰ã€ãŒå¤§ããªä¾¡å€¤ã®ã²ã¨ã¤ã ã‚ˆâœ¨ ([Microsoft Learn][1])

[1]: https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing?utm_source=chatgpt.com "Event Sourcing pattern - Azure Architecture Center"
[2]: https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core?utm_source=chatgpt.com "NET and .NET Core official support policy"
[3]: https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-14?utm_source=chatgpt.com "What's new in C# 14"
