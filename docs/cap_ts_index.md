# 32章 詳細アウトライン 📘✨

## Part 0：ウォームアップ＆環境（1〜4章）🔰💻

### 第1章：分散って何が大変なの？を先に体感😵‍💫🌍

* **目的**：単体アプリの常識が崩れるポイントを知る
* **要点**：遅延⏳／部分故障💥／二重送信📨／順序ズレ🔀
* **ハンズオン**：わざと遅いAPIを作って「待ち」が起きるのを見る🐢
* **AI**：Copilotに“遅延入りHTTPサンプル”を作らせて読む🤖📄

### 第2章：Windows＋VS Codeで実験用プロジェクトを作る🧰✨

* **目的**：以後の章で迷わない“型”を作る
* **要点**：TS設定、実行コマンド、フォルダ構成
* **ハンズオン**：`apps/api` と `apps/worker` の2プロセス構成を作る📦
* **AI**：設定ファイル雛形をAIに出させて“意味を説明させる”🤖📝

### 第3章：題材ドメインを決める（在庫・注文・決済）🛒📦💳

* **目的**：抽象話をやめて、全部“この話”で統一する
* **要点**：どこが即時一致必須？どこは遅れてOK？
* **ハンズオン**：ユーザー画面の状態（処理中/完了）を紙に描く✍️
* **AI**：ユーザーストーリーをAIに整形してもらう🤖✨

### 第4章：ネットワークの現実（タイムアウト・切断・再送）🔌📨

* **目的**：「失敗するのが普通」を身体に入れる
* **要点**：タイムアウト、リトライで二重になる危険
* **ハンズオン**：通信をランダム失敗させるスイッチを付ける🎛️
* **AI**：失敗注入（fault injection）のアイデアをAIに出させる🤖💡

---

## Part 1：CAPの“肌感覚”（5〜10章）⚖️🔥

### 第5章：「整合性」って何が一致してる状態？🧠🔍

* **目的**：一致対象を言葉で分けられるようにする
* **要点**：状態（DB）／事実（イベント）／表示（画面）
* **ハンズオン**：同じ注文でも「画面は処理中・DBは確定」状態を作る
* **AI**：用語ミニ辞典をAIに作らせて貼る📖🤖

### 第6章：CAPを日常例で理解する（まずは暗記しない）🍞📦

* **目的**：C/A/Pの直感を作る
* **要点**：C=一致、A=応答、P=分断耐性
* **ハンズオン**：分断中の挙動を2パターン作る（拒否 vs 受付）
* **AI**：CAPの“たとえ話”を5案出させて一番良いの採用🤖✨

### 第7章：Partition（分断）を実験で起こす🧪🔌

* **目的**：「Pが起きうる」ことを疑わない脳にする
* **要点**：片方だけ落ちる、片方だけ遅い、が普通
* **ハンズオン**：片方のプロセスだけ通信遮断して挙動を見る
* **AI**：分断時のログ出力ポイントをAIに提案させる🤖🕵️‍♀️

### 第8章：CAPの結論（PがあるならCかAどっち？）⚖️💥

* **目的**：意思決定として説明できるようにする
* **要点**：P下ではCとAを同時に最大化できない
* **ハンズオン**：「在庫は拒否(C寄り)」「注文受付(A寄り)」を作り比べる
* **AI**：判断理由を文章化させて、自分の言葉で直す✍️🤖

### 第9章：どこは即時必須？どこは遅れてOK？を仕分ける🧩✅

* **目的**：業務ルールから“整合性の必要度”を分解する
* **要点**：危険度（お金💸/法務⚖️/UX😌）で分類
* **ハンズオン**：題材ドメインを「強整合/遅延OK」に色分け🟥🟨🟩
* **AI**：分類の基準チェックリストをAIに作らせる🤖📋

### 第10章：最終的整合性＝“UXで支える設計”🎨⏳

* **目的**：「遅れる世界の見せ方」を学ぶ
* **要点**：処理中表示、後で確定、失敗時の戻し
* **ハンズオン**：注文後に「反映待ち」ステータスを入れる
* **AI**：画面文言（安心させる言い方）をAIに量産させる💬🤖

---

## Part 2：最終的整合性の道具箱（11〜22章）🧰✨

### 第11章：整合性レベル① Strong vs Eventual 🧱🕊️

* **目的**：まず2択で語れるようにする
* **要点**：強整合＝遅い/落ちやすい、最終的＝速い/ズレる
* **ハンズオン**：同期確認あり/なしでレスポンス差を体感
* **AI**：メリデメ比較表をAIに作らせる📊🤖

### 第12章：整合性レベル② セッション保証（自分の書き込みは見たい）👤✅

* **目的**：初心者が好きな“当たり前”を保証する発想
* **要点**：Read-your-writes、Monotonic read（入門）
* **ハンズオン**：同一ユーザーだけ新しい値を優先して読む
* **AI**：実装方針をAIに説明させて理解チェック🤖🧠

### 第13章：レプリケーション入門（Leader-Follower）🪞👑

* **目的**：複製の基本パターンを知る
* **要点**：Leaderに書く、Followerは遅れて追従
* **ハンズオン**：Followerを遅延させて“古い読み取り”を再現
* **AI**：図解（文章ベース）をAIに作らせる🗺️🤖

### 第14章：読む場所を選ぶ（Primary/Replica/Cache）👀🧭

* **目的**：「どこから読む？」でUXが変わるのを知る
* **要点**：速さ vs 新しさ
* **ハンズオン**：読取先を切替できるフラグを実装🎛️
* **AI**：判断フローチャートをAIに作らせる🤖🧩

### 第15章：書き方を選ぶ（同期/非同期/キュー）✍️📬

* **目的**：A寄り設計の“受付→後処理”を作る
* **要点**：非同期化、キュー、再試行
* **ハンズオン**：APIは受付だけ→Workerが後で反映
* **AI**：最小構成のタスクキュー案をAIに出させる🤖📦

### 第16章：クォーラムの直感（多数決）🗳️✨

* **目的**：多数決で“ある程度の一致”を作る感覚
* **要点**：N/R/W、R+W>N のイメージだけ押さえる
* **ハンズオン**：3ノード擬似で「2票取れたらOK」を体験
* **AI**：練習問題（N/R/Wの組み合わせ）をAIに作らせる✍️🤖

### 第17章：古い読み取りを減らす工夫（超入門）🧹📚

* **目的**：ズレを小さくする“地味テク”を知る
* **要点**：read repair（雰囲気）、更新直後はPrimary読む等
* **ハンズオン**：更新直後だけPrimary読むルールを入れる
* **AI**：適用条件（いつ使う？）をAIに整理させる🤖✅

### 第18章：キャッシュの整合性（速いけど古い問題）🧊⚡

* **目的**：現場で超よく出る問題に慣れる
* **要点**：TTL、無効化、キャッシュミス時の再取得
* **ハンズオン**：TTLの長短で“古さ”が変わるのを確認
* **AI**：TTL決めの考え方をAIに質問してまとめる🤖📝

### 第19章：マージしやすいデータ設計①（カウンタ/加算）➕🔢

* **目的**：収束しやすい形に“最初から”しておく
* **要点**：いいね数は「上書き」より「加算」
* **ハンズオン**：加算型の更新に変更して競合を減らす
* **AI**：上書きが危ない理由をAIに説明させる🤖🧠

### 第20章：マージしやすいデータ設計②（集合/履歴/イベント）📚🧩

* **目的**：上書きしない表現（履歴・集合）を知る
* **要点**：タグは集合、操作は履歴、表示は集計
* **ハンズオン**：操作ログ→集計で画面表示を作る
* **AI**：イベント設計の命名案をAIに出させる🤖🏷️

### 第21章：競合の正体（同時更新で壊れるパターン）💥⚔️

* **目的**：競合を“再現”できるようにする
* **要点**：lost update、二重反映、取り消し漏れ
* **ハンズオン**：同時更新で値が変になるテストを作る
* **AI**：競合テストケースをAIに量産させる🧪🤖

### 第22章：競合解決の選び方（LWW/ルール/マージ）🎛️🧠

* **目的**：「どの解決策が合うか」を判断できる
* **要点**：LWWは簡単だけど危険、ドメインルールが強い
* **ハンズオン**：LWW版とルール版を比較して事故を見る😱
* **AI**：解決策の選定基準をAIにチェックリスト化🤖📋

---

## Part 3：順序・収束・CRDT（23〜26章）🔀🧲

### 第23章：順序問題① 逆順・遅延・重複配達📨🔀

* **目的**：メッセージは“きれいに届かない”を理解
* **要点**：逆順、重複、遅延はセットで来る
* **ハンズオン**：わざとシャッフルして処理し、壊れ方を見る
* **AI**：シャッフル/遅延ユーティリティ案をAIに出させる🤖🧰

### 第24章：順序問題② 因果（ざっくり）とバージョン付け🧵🕰️

* **目的**：“どっちが先？”を判断する最低限の考え方
* **要点**：単純なversion番号、更新の前後関係
* **ハンズオン**：versionが古い更新は弾く（もしくは再取得）
* **AI**：設計の注意点（時計ズレ等）をAIに列挙させる🤖⚠️

### 第25章：CRDT入門①「勝手に収束する」ってどういうこと？🧲✨

* **目的**：CRDTの思想を雰囲気で掴む（数学はやらない）
* **要点**：マージ可能、順序が違っても収束しやすい
* **ハンズオン**：収束する/しないデータの違いを比較
* **AI**：説明用の例え話をAIに作らせる🤖🌈

### 第26章：CRDT入門② G-Counter風で“収束体験”🔢🌱

* **目的**：手を動かして“収束”を経験する
* **要点**：各ノードの値をマージして合意を作る
* **ハンズオン**：ノード別カウント→合成→一致を確認
* **AI**：コメントを丁寧に書かせて読みやすくする🤖📝

---

## Part 4：信頼性（リトライ・冪等・配達保証）＆運用（27〜30章）🔁🧷🕵️‍♀️

### 第27章：リトライ設計（バックオフ/ジッター/タイムアウト）🔁⏳

* **目的**：リトライは“薬にも毒にもなる”を理解
* **要点**：指数バックオフ、ジッター、最大回数
* **ハンズオン**：失敗率を上げて、リトライで安定化させる
* **AI**：よくあるミス（雪崩リトライ等）をAIに出させる🤖❄️

### 第28章：冪等性（同じ要求が何回来ても壊れない）🧷✅

* **目的**：二重実行の現実に強くなる
* **要点**：冪等キー、重複排除、状態遷移の二重適用防止
* **ハンズオン**：同じ注文IDを2回送っても1回分にする
* **AI**：冪等のテスト（同一キー2回）をAIに作らせる🧪🤖

### 第29章：配達保証の現実（Exactly-onceは幻👻）📨

* **目的**：現実的な前提（At-least-once）で設計する
* **要点**：重複が来る、欠落もある → だから冪等＆再同期
* **ハンズオン**：同じイベントを3回流しても壊れない設計にする
* **AI**：設計方針を“人に説明する文章”にAIで整える✍️🤖

### 第30章：観測（ログ/相関ID/主要メトリクス）🕵️‍♀️📈

* **目的**：ズレや遅延が起きても追えるようにする
* **要点**：相関ID、遅延、失敗理由、リトライ回数
* **ハンズオン**：1リクエストの流れをIDで追跡できるようにする🧵
* **AI**：ログに出すべき項目テンプレをAIに作らせる🤖📋

---

## Part 5：テスト＆卒業制作（31〜32章）🎓🚀

### 第31章：分散っぽいバグを捕まえるテスト（故障注入）🧪🎲

* **目的**：遅延・分断・重複をテストで再現する
* **要点**：フェイク/スタブ、ランダム遅延、ランダム失敗
* **ハンズオン**：故障注入ONでテストが落ちないように直す
* **AI**：テスト観点（何を壊す？）をAIに洗い出させる🤖✅

### 第32章：卒業制作（ミニ分散EC）🛒📦🎓✨

* **目的**：CAPと最終的整合性を“選んで説明できる成果物”を作る
* **要件**：

  * 注文は受付（A寄り）→後で収束（最終的整合性）⏳
  * 二重送信でも壊れない（冪等）🧷
  * リトライしても破綻しない🔁
  * 相関IDで追える🕵️‍♀️
* **成果物**：デモ動画orスクショ＋「C/Aどっち寄り？なぜ？」の説明文📝
* **AI**：READMEの構成案をAIに出させて、自分の言葉で仕上げる🤖✨

---

## いい感じの運用ルール（この教材の“勝ち筋”）🏆😊

* 1章ごとに「**結論1行**」を書いてから次へ✍️✨
* 実装はいつも「**最小で動く→壊す→直す**」の順🧪🔨✅
* AIは「生成」より「レビュー役」で使うと伸びるよ🤖👀

---
